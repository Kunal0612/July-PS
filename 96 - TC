/*

https://codeforces.com/problemset/problem/850/F

Write a C++ Solution RainbowBalls to find the ans after applying the operation told.

You have a bag of balls of len different colors. You have nums[i] balls of the i-th color.

While there are at least two different colored balls in the bag, perform the following steps:

Take out two random balls without replacement one by one. These balls might be the same color.

Color the second ball to the color of the first ball. You are not allowed to switch the order of the balls in this step.

Place both balls back in the bag.

All these actions take exactly one second.

Let M = 10^9 + 7. It can be proven that the expected amount of time needed before you stop can be represented as a rational number , where P and Q are coprime integers and where Q is not divisible by M. Return the value P*Q^(-1) % mod.

Input :

A vector of long long integer nums.

Constraints:

nums.size() : ranges from 1 to 2500.
nums : ranges from 1 to 10^5.

Output:

An integer ans after applying the operation told.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <stdexcept>

long long ModuloInverse(long long first, long long sec) {
    long long mod = 1e9 + 7;
    long long sum = 1;
    for (; sec; sec >>= 1, first = first * first % mod){
        if (sec & 1){
            sum = sum * first % mod;
        }
    }
    return sum;
}



int RainbowBalls(std::vector<long long> nums){
    int len=nums.size();
    if (len < 1 || len > 2500) {
        throw std::invalid_argument("The number of colors (len) must be between 1 and 2500.");
    }
    for (int i = 0; i < len; ++i) {
        if (nums[i] < 1 || nums[i] > 100000) {
            throw std::invalid_argument("Each element of the array nums must be between 1 and 10^5.");
        }
    }
    std::vector<long long> arr(len + 1);
    long long sum = 0, mxi = 0;
    long long mod = 1e9 + 7;
    for (long long i = 1; i <= len; i++) {
        arr[i]=nums[i-1];
        sum = (sum + arr[i]) % mod;
        mxi = std::max(mxi, arr[i]);
    }
    
    std::vector<long long> gmap(mxi + 1), frr(mxi + 1);
    
    gmap[0] = (mod - ModuloInverse(sum, mod - 2) * (sum - 1) % mod) % mod;
    
    for (long long i = 1; i <= mxi; i++) {
        gmap[i] = (gmap[i - 1] + ModuloInverse(i - sum + mod, mod - 2) * (sum - 1) % mod) % mod;
        frr[i] = (frr[i - 1] + gmap[i - 1]) % mod;
    }
    
    long long ans = 0;
    for (long long i = 1; i <= len; i++) {
        ans = (ans + frr[arr[i]]) % mod;
    }
    
    ans = (ans + sum * (sum - 1) % mod) % mod;
    return ans;
}


#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <stdexcept>

int main() {
    long long len;
    std::cin >> len;
    std::vector<long long int> nums(len);
    for(int i=0;i<len;i++){
        std::cin>>nums[i];
    }
    long long int ans=RainbowBalls(nums);
    std::cout << ans << std::endl;

    return 0;
}
