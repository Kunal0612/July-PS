// https://codeforces.com/problemset/problem/1830/D

#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <utility>
#include <limits>
#include <stdexcept>



struct DPState {
    std::vector<long long> arr;
    std::vector<long long> brr;
    int lim = 893;
    long long inf = std::numeric_limits<long long>::max();
    void Init() {
        arr.resize(lim + 1, inf);
        brr.resize(lim + 1, inf);
        arr[1] = 1;
        brr[1] = 2;
    }
};

/*


Input :

An integer num_nodes.
A vector of vector of integers edge.

Constraints :

num_nodes : ranges from 1 to 200000.
edge.size() : is of size num_nodes - 1.
edge : ranges from 1 to num_nodes and edge[i][0]!=edge[i][1].


*/


int MexTree(int num_nodes,std::vector<std::vector<int>> edge) {
    if (num_nodes < 1 || num_nodes > 200000) {
        throw std::invalid_argument("Invalid number of num_nodes: " + std::to_string(num_nodes) + ". It should be within the range 1 ≤ n ≤ 2⋅10^5.");
    }
    if (edge.size() != num_nodes - 1) {
        throw std::invalid_argument("Number of edges does not match n-1.");
    }
    for (std::vector<int>& it : edge) {
        int node_a = it[0];
        int node_b = it[1];
        if (node_a < 1 || node_a > num_nodes || node_b < 1 || node_b > num_nodes || node_a == node_b) {
            throw std::invalid_argument("Invalid edge: (" + std::to_string(node_a) + ", " + std::to_string(node_b) + "). It should satisfy 1 ≤ ai, bi ≤ n and ai ≠ bi.");
        }
    }
    std::vector<std::vector<int>> graph(num_nodes + 1);
    std::vector<int> size(num_nodes + 1);
    std::vector<std::pair<int, int>> edges;

    for (int i = 1; i < num_nodes; ++i) {
        int node_x=edge[i-1][0], node_y=edge[i-1][1];
        graph[node_x].push_back(node_y);
        graph[node_y].push_back(node_x);
        edges.push_back({node_x, node_y});
    }
    std::function<int(int, int)> shuffle_kids = [&](int node, int parent) {
        int size = 1;
        std::pair<int, int> best;
        for (int i = 0; i < (int)graph[node].size(); ++i) {
            if (graph[node][i] != parent) {
                int sub_size = shuffle_kids(graph[node][i], node);
                best = std::max(best, {sub_size, i});
                size += sub_size;
            }
        }
        if (!graph[node].empty()) {
            std::swap(graph[node][0], graph[node][best.second]);
        }
        return size;
    };

    shuffle_kids(1, 0);
    int lim = 893;
    long long inf = std::numeric_limits<long long>::max();
    std::vector<std::vector<long long>> merged(2 * lim + 1, std::vector<long long>(2, inf));

    std::function<DPState(int, int)> dfs = [&](int node, int parent) {
        DPState dp_table;
        size[node] = 1;
        bool initialized = false;

        for (int child : graph[node]) {
            if (child != parent) {
                DPState child_dp = dfs(child, node);
                if (!initialized) {
                    dp_table.Init();
                    initialized = true;
                }
                for (int j = 0; j <= std::min(size[node], lim) + std::min(size[child], lim); ++j) {
                    merged[j][0] = merged[j][1] = inf;
                }
                for (int k = 1; k <= std::min(size[node], lim); ++k) {
                    for (int l = 1; l <= std::min(size[child], lim); ++l) {
                        merged[k][0] = std::min(merged[k][0], dp_table.arr[k] + child_dp.brr[l]);
                        merged[k][1] = std::min(merged[k][1], dp_table.brr[k] + child_dp.arr[l]);
                        merged[k + l][0] = std::min(merged[k + l][0], dp_table.arr[k] + child_dp.arr[l] + k * l);
                        merged[k + l][1] = std::min(merged[k + l][1], dp_table.brr[k] + child_dp.brr[l] + k * l * 2);
                    }
                }
                size[node] += size[child];
                for (int k = 1; k <= std::min(size[node], lim); ++k) {
                    dp_table.arr[k] = merged[k][0];
                    dp_table.brr[k] = merged[k][1];
                }
            }
        }
        if (!initialized) {
            dp_table.Init();
            initialized = true;
        }
        return dp_table;
    };

    DPState dp_table = dfs(1, 0);
    long long ans = inf;
    for (int i = 1; i <= lim; ++i) {
        ans = std::min(ans, dp_table.arr[i]);
        ans = std::min(ans, dp_table.brr[i]);
    }
    int answer=num_nodes * (num_nodes + 1) - ans;
    return answer;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <utility>
#include <limits>
#include <stdexcept>


int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    int queries;
    std::cin >> queries;
    
    while (queries--) {
        int n;
        std::cin>>n;
        std::vector<std::vector<int>> edge;
        for(int i=0;i<n-1;i++){
            int x,y;
            std::cin >> x >> y;
            edge.push_back({x,y});
        }
        int ans=MexTree(n,edge);
        std::cout << ans << std::endl;
    }
    return 0;
}
