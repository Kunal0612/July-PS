// https://codeforces.com/problemset/problem/1876/D

#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <cassert>
#include <stdexcept>



int BinPow(int base, int exp, int mod) {
    int result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

int Find(int node, std::vector<int>& parent) {
    return node == parent[node] ? node : parent[node] = Find(parent[node], parent);
}


/*

Input :

A vector of integers nums.

Constraints :

nums : ranges from 1 to 200000.
nums.size() : ranges from 1 to 200000.

*/


int Lexichromatography(std::vector<int> &nums){
    int len=nums.size();
    if(len<1 or len>200000){
        throw std::invalid_argument("Invalid length");
    }
    for(int i=0;i<len;i++){
        if(nums[i]<1 or nums[i]>200000){
            throw std::invalid_argument("Invalid nums");
        }
    }
    std::vector<int> values(len + 1);
    std::vector<int> parent(len + 1);
    std::vector<int> power(len + 1, 1);
    std::vector<std::vector<int>> positions(len+1);
    int mod = 998244353;
    for (int i = 1; i <= len; ++i) {
        values[i]=nums[i-1];
        parent[i] = i;
        power[i] = (power[i - 1] * 2) % mod;
        positions[values[i]].push_back(i);
    }

    int node = 0;
    for (const std::vector<int>& pos : positions) {
        if (!pos.empty()) {
            node++;
        }
    }

    std::vector<std::pair<int, int>> segments;
    for (int i = 1; i < len+1; ++i) {
        if (positions[i].size() % 2 != 0) {
            return power[node - 1];
        } else {
            for (int j = 1; j < positions[i].size(); ++j) {
                parent[Find(positions[i][j], parent)] = Find(positions[i][j - 1], parent);
            }
            for (int j = 0; j < positions[i].size(); j += 2) {
                segments.push_back({positions[i][j], positions[i][j + 1]});
            }
        }
    }

    std::sort(segments.begin(), segments.end());
    for (int i = 1, r = segments[0].second; i < segments.size(); ++i) {
        if (segments[i].second < r) {
            return power[node - 1];
        } 
        else {
            if (segments[i].first < r) {
                parent[Find(segments[i].second, parent)] = Find(r, parent);
            }
            r = std::max(r, segments[i].second);
        }
    }
    int yec = 0;
    for (int i = 1; i <= len; ++i) {
        if (Find(i, parent) == i) {
            yec++;
        }
    }
    int ans=(power[node - 1] + mod - power[yec - 1]) % mod;
    return ans;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
#include <cassert>
#include <stdexcept>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int len;
    std::cin >> len;
    std::vector<int> nums(len);
    for (int i = 0; i < len; i++) {
        std::cin >> nums[i];
    }
    int ans=Lexichromatography(nums);
    std::cout << ans << std::endl;
    return 0;
}
