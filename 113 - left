// https://codeforces.com/problemset/problem/1580/D

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <cassert>
#include <stdexcept>



struct TreeSolver {
    int len, max_m;
    std::vector<int> values, left_subtree, right_subtree, left_weight, right_weight, subtree_size;
    std::vector<std::vector<long long int>> dp_table;

    TreeSolver(int n, int m) : len(n), max_m(m), values(n + 1), left_subtree(n + 1), 
    right_subtree(n + 1), left_weight(n + 1), right_weight(n + 1), subtree_size(n + 1), 
    dp_table(n + 1, std::vector<long long int>(m + 1, 0)) {}

    void UpdateMax(long long int &first, long long int sec) {
        first = first < sec ? sec : first;
    }

    void DepthFirstSearch(int node) {
        subtree_size[node] = 1;
        if (left_subtree[node]) {
            DepthFirstSearch(left_subtree[node]);
            for (int i = std::min(max_m, subtree_size[node]); i >= 0; i--){
                for (int j = std::min(max_m, subtree_size[left_subtree[node]]); j >= 0; j--){
                    UpdateMax(dp_table[node][i + j], dp_table[node][i] + dp_table[left_subtree[node]][j] + 1ll * j * (max_m - j) * left_weight[node]);
                }
            }
            subtree_size[node] += subtree_size[left_subtree[node]];
        }
        if (right_subtree[node]) {
            DepthFirstSearch(right_subtree[node]);
            for (int i = std::min(max_m, subtree_size[node]); i >= 0; i--){
                for (int j = std::min(max_m, subtree_size[right_subtree[node]]); j >= 0; j--){
                    UpdateMax(dp_table[node][i + j], dp_table[node][i] + dp_table[right_subtree[node]][j] + 1ll * j * (max_m - j) * right_weight[node]);
                }
            }
            subtree_size[node] += subtree_size[right_subtree[node]];
        }
    }
};

/*
Input :

An integer max_m.
A vector of nums.

Constraints : 

max_m : ranges from 1 to len.
nums.size : ranges from 1 to 4000.
nums : ranges from 1 to 2^31.

*/


int Subsequence(int max_m,std::vector<int> &nums) {
    int len=nums.size();
    if (max_m < 1 || max_m > len) {
        throw std::invalid_argument("Invalid value of max_m: 1 ≤ max_m ≤ len must hold.");
    }
    if (len < 1 || len > 4000) {
        throw std::invalid_argument("Invalid value of len: 1 ≤ len ≤ 4000 must hold.");
    }
    for (int i = 0; i < len; i++) {
        if (nums[i] < 1 || nums[i] >= (1LL << 31)) {
            throw std::invalid_argument("Invalid value of nums[i]: 1 ≤ nums[i] < 2^31 must hold.");
        }
    }
    TreeSolver solver(len, max_m);
    std::vector<int> &values = solver.values;
    std::vector<int> &left_subtree = solver.left_subtree;
    std::vector<int> &right_subtree = solver.right_subtree;
    std::vector<int> &left_weight = solver.left_weight;
    std::vector<int> &right_weight = solver.right_weight;
    std::vector<std::vector<long long int>> &dp_table = solver.dp_table;
    std::vector<int> &subtree_size = solver.subtree_size;

    std::vector<int> stack(len + 1);
    int top = 0;
    for (int i = 1; i <= len; i++) {
        values[i]=nums[i-1];
        int kec = top;
        for (; kec && values[i] < values[stack[kec]]; kec--);
        if (kec) {
            right_subtree[stack[kec]] = i;
            right_weight[stack[kec]] = values[i] - values[stack[kec]];
        }
        if (kec < top) {
            left_subtree[i] = stack[kec + 1];
            left_weight[i] = values[stack[kec + 1]] - values[i];
        }
        stack[++kec] = i;
        top = kec;
    }
    solver.DepthFirstSearch(stack[1]);
    int ans=dp_table[stack[1]][max_m];
    return ans;
}

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <cassert>
#include <stdexcept>


int main() {
    int len, max_m;
    std::cin>>len>>max_m;
    std::vector<int> nums(len);
    for(int i=0;i<len;i++){
        std::cin>>nums[i];
    }
    int ans=Subsequence(max_m,nums);
    std::cout<<ans<<std::endl;
    return 0;
}

