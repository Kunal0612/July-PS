// https://codeforces.com/problemset/problem/1422/F


#include <iostream>
#include <algorithm>
#include <map>
#include <vector>
#include <cmath>
#include <vector>
#include <functional>
#include <cassert>
#include <stdexcept>


struct TreeNode {
    std::vector<std::pair<int, int>> low;
    std::vector<std::pair<int, int>> high;
    std::vector<int> product;
};

void NodeMerge(const TreeNode& left_node, const TreeNode& right_node, TreeNode& result_node) {
    auto left_it = left_node.low.begin();
    auto right_it = right_node.low.begin();
    while (left_it != left_node.low.end() || right_it != right_node.low.end()) {
        if (right_it == right_node.low.end() || (left_it != left_node.low.end() && left_it->first < right_it->first)) {
            result_node.low.emplace_back(left_it->first, left_it->second);
            ++left_it;
        } else if (left_it == left_node.low.end() || (right_it != right_node.low.end() && right_it->first < left_it->first)) {
            result_node.low.emplace_back(right_it->first, right_it->second);
            ++right_it;
        } else {
            result_node.low.emplace_back(left_it->first, std::max(left_it->second, right_it->second));
            ++left_it;
            ++right_it;
        }
    }
    std::merge(left_node.high.begin(), left_node.high.end(), right_node.high.begin(), right_node.high.end(), std::back_inserter(result_node.high));
    int mod = (int)1e+9 + 7;
    int product = 1;
    for (std::pair<int,int>& it : result_node.high) {
        int xec=it.second;
        product = product * static_cast<long long>(xec) % mod;
        result_node.product.push_back(product);
    }
}

void BuildTree(int index, int left, int right, const std::vector<int>& nums, std::vector<TreeNode>& tree, std::map<int, int>& last, const std::vector<int>& primes) {
    int mx_range = (int)sqrt(2e+5 + 42);
    if (left + 1 == right) {
        int xec = nums[left];
        for (const int& prime : primes) {
            if (prime * prime > xec) {
                break;
            }
            int count = 0;
            while (xec % prime == 0) {
                xec /= prime;
                ++count;
            }
            if (count) {
                tree[index].low.emplace_back(prime, count);
            }
        }
        if (xec > 1) {
            if (xec >= mx_range) {
                auto it = last.find(xec);
                int prev = it == last.end() ? -1 : it->second;
                tree[index].high.emplace_back(prev, xec);
                tree[index].product.emplace_back(xec);
                last[xec] = left;
            } else {
                tree[index].low.emplace_back(xec, 1);
            }
        }
        return;
    }

    int mid = (left + right) / 2;
    int leftIndex = 2 * index;
    int rightIndex = 2 * index + 1;
    BuildTree(leftIndex, left, mid, nums, tree, last, primes);
    BuildTree(rightIndex, mid, right, nums, tree, last, primes);
    NodeMerge(tree[leftIndex], tree[rightIndex], tree[index]);
}

void GetResult(int index, int left, int right, int query_left, int query_right, std::vector<TreeNode>& tree, int& count, std::vector<int>& update, std::vector<int>& sequence, std::vector<int>& value, int& answer) {
    int mod = (int)1e+9 + 7;
    if (query_left <= left && right <= query_right) {
        for (const std::pair<int,int>& it : tree[index].low) {
            int prime=it.first;
            int power=it.second;
            if (update[prime] != count) {
                update[prime] = count;
                sequence.push_back(prime);
                value[prime] = 0;
            }
            value[prime] = std::max(value[prime], power);
        }

        int pos = std::lower_bound(tree[index].high.begin(), tree[index].high.end(), std::make_pair(query_left, 0)) - tree[index].high.begin();
        if (pos) {
            answer = answer * static_cast<long long>(tree[index].product[pos - 1]) % mod;
        }
        return;
    }

    int mid = (left + right) / 2;
    int leftIndex = 2 * index;
    int rightIndex = 2 * index + 1;

    if (query_left < mid) {
        GetResult(leftIndex, left, mid, query_left, query_right, tree, count, update, sequence, value, answer);
    }

    if (mid < query_right) {
        GetResult(rightIndex, mid, right, query_left, query_right, tree, count, update, sequence, value, answer);
    }
}

int Powmod(int base, int exp) {
    int mod = (int)1e+9 + 7;
    long long result = 1;
    long long power = base;
    while (exp) {
        if (exp & 1) {
            result = result * power % mod;
        }
        power = power * power % mod;
        exp >>= 1;
    }
    return result;
}

std::vector<int> solve(std::vector<int> nums,std::vector<std::vector<int>> query){
    int mx_range = (int)sqrt(2e+5 + 42);
    int max_n = 1e+5 + 42;
    int max_t = 4 * max_n;
    int mod = (int)1e+9 + 7;
    std::vector<int> is_prime(mx_range, 1);
    std::vector<int> primes;
    for (int i = 2; i < mx_range; ++i) {
        if (!is_prime[i]) {
            continue;
        }
        primes.push_back(i);
        if (i <= mx_range / i) {
            for (int j = i * i; j < mx_range; j += i) {
                is_prime[j] = false;
            }
        }
    }

    int len=nums.size();
    /*

    Input : 
    A vector of integers nums.
    A vector of vector of integers query.

    Constraints :
    nums.size() : ranges from 1 to 100000.
    nums : ranges from 1 to 200000.
    query.size() : ranges from 1 to 100000.
    query : query[i][0] ranges from 1 to nums.size() , query[i][1] ranges from 1 to nums.size().

    */
    int q_len=query.size();
    if (len < 1 || len > 100000) {
        throw std::invalid_argument("n must be between 1 and 100000 inclusive.");
    }
    for (int i = 0; i < len; ++i) {
        if (nums[i] < 1 || nums[i] > 200000) {
            throw std::invalid_argument("Array elements must be between 1 and 200000 inclusive.");
        }
    }

    if (q_len < 1 || q_len > 100000) {
        throw std::invalid_argument("q must be between 1 and 100000 inclusive.");
    }

    for (const std::vector<int>& quer : query) {
        int left = quer[0];
        int right = quer[1];
        if (left < 1 || left > len || right < 1 || right > len) {
            throw std::invalid_argument("Query indices must be between 1 and n inclusive.");
        }
    }
    std::vector<TreeNode> tree(max_t);
    std::map<int, int> last;
    int root = 1;
    BuildTree(root, 0, len, nums, tree, last, primes);

    std::vector<int> update(mx_range, 0);
    std::vector<int> value(mx_range, 0);
    std::vector<int> sequence(mx_range, 0);
    int count = 0;
    int answer = 0;
    std::vector<int> ans;
    for (int q = 0; q < q_len; ++q) {
        int left=query[q][0], right=query[q][1];
        left = (left + answer) % len;
        right = (right + answer) % len;
        if (left > right) {
            std::swap(left, right);
        }

        ++count;
        sequence.clear();

        answer = 1;
        GetResult(root, 0, len, left, right + 1, tree, count, update, sequence, value, answer);

        for (const auto& prime : sequence) {
            answer = answer * static_cast<long long>(Powmod(prime, value[prime])) % mod;
        }
        ans.push_back(answer);
    }
    return ans;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int n;
    std::cin>>n;
    std::vector<int> a(n);
    for(int i=0; i<n; i++){
        std::cin>>a[i];
    }
    int m;
    std::cin>>m;
    std::vector<std::vector<int>> vp;
    for(int i=0; i<m; i++){
        int x,y;
        std::cin>>x>>y;
        vp.push_back({x,y});
    }
    std::vector<int> ans=solve(a,vp);
    for(auto x:ans){
        std::cout<<x<<std::endl;;
    }

    return 0;
}
