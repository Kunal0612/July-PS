/*

https://codeforces.com/problemset/problem/1809/F

Write a C++ Solution TravelingInBerland to find a ans vector where the i-th of 
them is equal to the minimum cost of the journey if you start and finish in the 
i-th city.

There are num_cities cities in Berland, arranged in a circle and numbered from 
1 to num_cities in clockwise order.

You want to travel all over Berland, starting in some city, visiting all the other 
cities and returning to the starting city. Unfortunately, you can only drive along 
the Berland Ring Highway, which connects all num_cities cities. The road was designed 
by a very titled and respectable minister, so it is one-directional â€” it can only be 
traversed clockwise, only from the city i to the 
city (i%num_cities)+1 (i.e. from 1 to 2, from 2 in 3, ..., from num_cities to 1).

The fuel tank of your car holds up to fuel_volume liters of fuel. To drive from 
the i-th city to the next one, fuel_cost[i]
liters of fuel are needed (and are consumed in the process).

Every city has a fuel station :  a liter of fuel in the i-th city costs city_type[i] burles. 
Refueling between cities is not allowed :  if fuel has run out between cities, then 
your journey is considered incomplete.

For each city, calculate the minimum cost of the journey if you start and finish it in that city.


Input :

An integer num_cities.
An integer fuel_voloume.
A vector of integers fuel_cost
A vector of integers city_type.


Constraints :

city_type.size() ==  fuel_cost.size() : ranges from 3 to 200000.
fuel_voloume : ranges from 1 to 10^9.
city_type : ranges from 1 to 2.
fuel_cost : ranges from 1 to fuel_voloume.

Output:

An vector of integer ans where the i-th of them is equal to the minimum cost of the 
journey if you start and finish in the i-th city.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <stdexcept>


std::vector<int> TravelingInBerland(int fuel_voloume, std::vector<int> fuel_cost, std::vector<int> city_type)
{
    int num_cities = fuel_cost.size();

    if (num_cities < 3 || num_cities > 200000 || fuel_voloume < 1 || fuel_voloume > 1000000000)
    {
        throw std::invalid_argument("Invalid input: Ensure 3 <= num_cities <= 200000 and 1 <= fuel_voloume <= 1000000000");
    }
    for (int i = 0; i < num_cities; ++i)
    {
        if (fuel_cost[i] < 1 || fuel_cost[i] > fuel_voloume)
        {
            throw std::invalid_argument("Invalid input: Ensure 1 <= fuel_cost[i] <= fuel_voloume");
        }
    }
    for (int i = 0; i < num_cities; ++i)
    {
        if (city_type[i] < 1 || city_type[i] > 2)
        {
            throw std::invalid_argument("Invalid input: Ensure 1 <= city_type[i] <= 2");
        }
    }

    std::vector<long long> prefix_sum(2 * num_cities + 1);
    for (int i = 0; i < 2 * num_cities; ++i)
    {
        prefix_sum[i + 1] = prefix_sum[i] + fuel_cost[i % num_cities];
    }

    std::vector<long long> distance(num_cities);
    std::vector<long long> cost(num_cities);
    int count = 0;
    for (int i = 2 * num_cities - 1; i >= 0; --i)
    {
        if (i < num_cities)
        {
            if (city_type[i] == 2)
            {
                distance[i] = 1;
                cost[i] = fuel_cost[i] * 2;
            }
            else if (count == 0)
            {
                distance[i] = 1;
                cost[i] = fuel_cost[i];
            }
            else
            {
                int jdx = std::lower_bound(prefix_sum.begin() + i, prefix_sum.begin() + i + count + 1, prefix_sum[i] + fuel_voloume) - prefix_sum.begin();
                assert(jdx > i);
                distance[i] = jdx - i;
                if (prefix_sum[jdx] - prefix_sum[i] <= fuel_voloume){
                    cost[i] = prefix_sum[jdx] - prefix_sum[i];
                }
                else{
                    cost[i] = 2 * (prefix_sum[jdx] - prefix_sum[i]) - fuel_voloume;
                }
            }
        }
        if (city_type[i % num_cities] == 2)
        {
            ++count;
        }
        else
        {
            count = 0;
        }
    }

    int power = 0;
    while ((1 << power) <= num_cities){
        ++power;
    }

    std::vector<std::vector<long long>> distance_k(power, distance);
    std::vector<std::vector<long long>> cost_k(power, cost);
    for (int jdx = 1; jdx < power; ++jdx)
    {
        for (int i = 0; i < num_cities; ++i)
        {
            distance_k[jdx][i] = distance_k[jdx - 1][i] + distance_k[jdx - 1][(i + distance_k[jdx - 1][i]) % num_cities];
            cost_k[jdx][i] = cost_k[jdx - 1][i] + cost_k[jdx - 1][(i + distance_k[jdx - 1][i]) % num_cities];
        }
    }
    std::vector<int> ans;
    for (int i = 0; i < num_cities; ++i)
    {
        int position = i;
        long long total = 0;
        long long answer = 0;
        for (int jdx = power - 1; jdx >= 0; --jdx)
        {
            if (total + distance_k[jdx][position] <= num_cities)
            {
                total += distance_k[jdx][position];
                answer += cost_k[jdx][position];
                position = (position + distance_k[jdx][position]) % num_cities;
            }
        }
        if (total < num_cities){
            answer += prefix_sum[i + num_cities] - prefix_sum[i + total];
        }
        ans.push_back(answer);
    }
    return ans;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <stdexcept>


int main()
{
    int testCases;
    if (scanf("%d", &testCases) != 1)
    {
        throw std::invalid_argument("Failed to read the number of test cases.");
    }
    while (testCases--)
    {
        int num_cities, fuel_voloume;
        if (scanf("%d%d", &num_cities, &fuel_voloume) != 2)
        {
            throw std::invalid_argument("Failed to read input values.");
        }
        std::vector<int> fuel_cost(num_cities);
        for (int i = 0; i < num_cities; ++i)
        {
            if (scanf("%d", &fuel_cost[i]) != 1)
            {
                throw std::invalid_argument("Failed to read input values.");
            }
            if (fuel_cost[i] < 1 || fuel_cost[i] > fuel_voloume)
            {
                throw std::invalid_argument("Invalid input: Ensure 1 <= fuel_cost[i] <= fuel_voloume");
            }
        }

        std::vector<int> city_type(num_cities);
        for (int i = 0; i < num_cities; ++i)
        {
            if (scanf("%d", &city_type[i]) != 1)
            {
                throw std::invalid_argument("Failed to read input values.");
            }
        }
        std::vector<int> ans=TravelingInBerland(fuel_voloume,fuel_cost,city_type);
        for(int x:ans){
            std::cout<<x<<" ";
        }
        std::cout<<std::endl;
    }
}
