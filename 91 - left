// https://codeforces.com/problemset/problem/1821/F

#include <algorithm>
#include <cstdio>
#include <vector>
#include <iostream>
#include <cassert>
#include <stdexcept>



int Add(int first, int sec) {
    int mod = 998244353;
    first += sec;
    if (first >= mod){
        first -= mod;
    }
    if (first < 0){
        first += mod;
    }
    return first;
}

int Mul(int first, int sec) {
    int mod = 998244353;
    return first * 1ll * sec % mod;
}

int BinPow(int base, int exponent) {
    int result = 1;
    while (exponent) {
        if (exponent & 1){
            result = Mul(result, base);
        }
        base = Mul(base, base);
        exponent >>= 1;
    }
    return result;
}

int Comb(int num_spots, int k_value, const std::vector<int>& fact, const std::vector<int>& fact_1) {
    if (k_value < 0 || num_spots < 0 || k_value > num_spots){
        return 0;
    }
    return Mul(fact[num_spots], Mul(fact_1[k_value], fact_1[num_spots - k_value]));
}

int superbinom(int num_spots, int k_value, const std::vector<int>& fact, const std::vector<int>& fact_1) {
    return Comb(num_spots + k_value, k_value, fact, fact_1);
}

/*
Input :

An integer num_spots.
An integer num_trees.
An integer height.

Constraints :

num_trees,height : ranges from 1 to num_spots.
num_spots : ranges from height to 300000.

*/


int Timber(int num_spots, int num_trees,int height){
    if (num_trees < 1 || height < 1 || num_spots < num_trees || num_spots< height || num_spots > 300000) {
        throw std::invalid_argument("Invalid input: Ensure 1 <= num_trees, height <= num_spots <= 300000");
    }
    int mod = 998244353;
    std::vector<int> fact(2 * num_spots + 1), fact_1(2 * num_spots + 1);
    fact[0] = 1;
    for (int i = 1; i <= 2 * num_spots; ++i){
        fact[i] = Mul(fact[i - 1], i);
    }
    fact_1[2 * num_spots] = BinPow(fact[2 * num_spots], mod - 2);
    for (int i = 2 * num_spots - 1; i >= 0; --i){
        fact_1[i] = Mul(fact_1[i + 1], i + 1);
    }

    int pow_2 = 1;
    int answer = 0;
    for (int i = num_trees; i >= 0; --i) {
        int current = 0;
        if (num_spots - (num_trees - i) * 1ll * (height + 1) - i * 1ll * (2 * height + 1) >= 0){
            current = Mul(superbinom(num_spots - (num_trees - i) * (height + 1) - i * (2 * height + 1), num_trees, fact, fact_1), 
                          Mul(pow_2, Comb(num_trees, i, fact, fact_1)));
        }
        answer = Add(answer, i & 1 ? -current : current);
        pow_2 = Mul(pow_2, 2);
    }
    return answer;
}

#include <algorithm>
#include <cstdio>
#include <vector>
#include <iostream>
#include <cassert>
#include <stdexcept>


int main() {
    int num_spots, num_trees, height;
    scanf("%d%d%d", &num_spots, &num_trees, &height);
    int res=Timber(num_spots, num_trees, height);
    std::cout<<res;
}
