// https://codeforces.com/problemset/problem/1984/F

#include <iostream>
#include <vector>
#include <cstring>
#include <cassert>
#include <set>
#include <stdexcept>


int Reconstruction(int bound,std::string str,std::vector<int> nums) {
    int size=str.size();
    if(size<2 or size>2000 or bound<2 or bound>1000000000){
        throw std::invalid_argument("Invalid Constraints");
    }
    for(int i=0;i<size;i++){
        if(abs(nums[i])>size*bound*1LL){
            throw std::invalid_argument("Invalid Nums value");
        }
        if(str[i]!='P' and str[i]!='S' and str[i]!='?'){
            throw std::invalid_argument("Invalid String str");
        }
    }
    str = "P" + str + "S";
    int mod = 998244353;

    std::vector<long long> b_values(size + 2);
    for (int index = 0; index < size; ++index) {
        b_values[index + 1]=nums[index];
    }

    long long answer = 0;
    std::set<long long> done_sums;

    for (int index = 0; index < size + 1; ++index) {
        long long sum = b_values[index] + b_values[index + 1];
        if (done_sums.count(sum)) continue;

        std::vector<std::vector<int>> dpp(size + 2, std::vector<int>(2, -1));
        dpp[0][0] = 1;

        for (int j = 1; j < size + 2; ++j) {
            bool transitions[2] = {true, true};
            if (str[j] == 'P') transitions[1] = false;
            else if (str[j] == 'S') transitions[0] = false;

            if (std::abs(b_values[j] - b_values[j - 1]) <= bound) {
                for (int k = 0; k < 2; ++k) {
                    if (dpp[j - 1][k] > -1 && transitions[k]) {
                        dpp[j][k] = dpp[j - 1][k];
                    }
                }
            }

            if (dpp[j - 1][0] > -1 && transitions[1] && sum == b_values[j] + b_values[j - 1]) {
                if (dpp[j][1] < 0) dpp[j][1] = 0;
                dpp[j][1] = (dpp[j][1] + dpp[j - 1][0]) % mod;
            }

            if (dpp[j - 1][1] > -1 && transitions[0]) {
                long long add = b_values[j] + b_values[j - 1] - sum;
                long long large = std::max(std::abs(add / 2), std::abs(add - add / 2));
                if (large <= bound) {
                    if (dpp[j][0] < 0) dpp[j][0] = 0;
                    dpp[j][0] = (dpp[j][0] + dpp[j - 1][1]) % mod;
                }
            }
        }

        if (dpp[size + 1][1] < 0) continue;
        answer = (answer + dpp[size + 1][1]) % mod;
        done_sums.insert(sum);
    }
    return answer;
}

#include <iostream>
#include <vector>
#include <cstring>
#include <cassert>
#include <set>
#include <stdexcept>

int main() {
    return 0;
}
