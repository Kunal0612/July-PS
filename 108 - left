// https://codeforces.com/problemset/problem/1554/E


#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <cassert>
#include <stdexcept>



void AddEdge(std::vector<std::vector<int>>& graph, int node_u, int node_v, int num_nodes) {
    graph[node_u].push_back(node_v);
    graph[node_v].push_back(node_u);
}

void Dfs(int node, int parent, const std::vector<std::vector<int>>& graph, 
std::vector<int>& dp_table, bool& isValid, int dec) {
    if (!isValid){
        return;
    }
    for (int neighbor : graph[node]) {
        if (neighbor != parent) {
            Dfs(neighbor, node, graph, dp_table, isValid, dec);
        }
    }
    if (dp_table[node] % dec != 0) {
        if (parent) {
            dp_table[node]++;
        }
        if (dp_table[node] % dec != 0) {
            isValid = false;
            return;
        }
    } else {
        dp_table[parent]++;
    }
}

/*

Input :

An integer num_nodes.
A vector of pair of integers edges.

Constraints :

num_nodes : ranges from 2 to 100000.
edges.size() : equal to num_nodes - 1.
edges : ranges from 1 to num_nodes.

*/



std::vector<int> You(int num_nodes,std::vector<std::pair<int,int>>& edges) {
    if (num_nodes < 2 || num_nodes > 100000) {
        throw std::runtime_error("Number of num_nodes must be between 2 and 100000.");
    }
    if (edges.size() != num_nodes - 1) {
        throw std::runtime_error("Number of edges must be num_nodes - 1.");
    }
    for (std::pair<int,int> &edge : edges) {
        if (edge.first < 1 || edge.first > num_nodes || edge.second < 1 || edge.second > num_nodes) {
            throw std::runtime_error("Edge node indices must be within the valid range.");
        }
    }
    std::vector<std::vector<int>> graph(num_nodes + 1);
    for (std::pair<int,int> &edge : edges)
    {
        AddEdge(graph, edge.first, edge.second, num_nodes);
    }
    std::vector<int> result(num_nodes+1);
    std::fill(result.begin(), result.end(), 0);
    result[1] = 1;
    int mod = 998244353;
    for (int k = 1; k <= num_nodes - 1; k++) {
        result[1] = (result[1] * 2) % mod;
    }

    for (int dec = 2; dec <= num_nodes - 1; dec++) {
        if ((num_nodes - 1) % dec == 0) {
            bool isValid = true;
            std::vector<int> dp_table(num_nodes + 1, 0);
            Dfs(1, 0, graph, dp_table, isValid, dec);
            result[dec] = isValid;
        }
    }
    
    for (int i = num_nodes; i >= 1; i--) {
        for (int j = i + i; j <= num_nodes; j += i) {
            result[i] = (result[i] - result[j] + mod) % mod;
        }
    }
    std::vector<int> ans;
    for (int i = 1; i <= num_nodes; i++) {
        ans.push_back(result[i]);
    }
    return ans;
}


#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <cassert>
#include <stdexcept>


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int testCases;
    std::cin >> testCases;

    while (testCases--) {
        int num_nodes;
        std::cin >> num_nodes;

        std::vector<std::pair<int, int>> edges(num_nodes - 1);
        for (int i = 0; i < num_nodes - 1; i++) {
            int node_u, node_v;
            std::cin >> node_u >> node_v;
            edges[i] = {node_u, node_v};
        }
        std::vector<int> ans=You(num_nodes, edges);
        for(int &x:ans) {
            std::cout<<x<<" ";
        }
        std::cout<<std::endl;
    }

    return 0;
}
