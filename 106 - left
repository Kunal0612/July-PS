// https://codeforces.com/problemset/problem/1967/D

#include <functional>
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <cassert>
#include <stdexcept>

/*
Input :

An integer len.
An integer range.
An vector of integers arr.
An vector of integers arr.

Constraints :

len : ranges from 1 to 10^6.
range : ranges from 1 to 10^6.
arr.size() : equal to len.
brr.size() : equal to range.
arr : ranges from 1 to range.
brr : ranges from 1 to range.

*/


int LongWayToBeNondecreasing(int len,int range,std::vector<int> &arr,std::vector<int> &brr) {
    if (len < 1 || len > 1000000) {
        throw std::invalid_argument("len must be between 1 and 1000000");
    }
    if (range < 1 || range > 1000000) {
        throw std::invalid_argument("range must be between 1 and 1000000");
    }

    if (arr.size() != static_cast<size_t>(len)) {
        throw std::invalid_argument("The size of arr must be equal to n");
    }
    for (int& a : arr) {
        if (a < 1 || a > range) {
            throw std::invalid_argument("Each element in arr must be between 1 and range");
        }
    }
    if (brr.size() != static_cast<size_t>(range)) {
        throw std::invalid_argument("The size of brr must be equal to range");
    }
    for (int& b : brr) {
        if (b < 1 || b > range) {
            throw std::invalid_argument("Each element in brr must be between 1 and range");
        }
    }
    int total = 0;
    std::vector<int> array_a(len), array_b(range + 1), visited(range + 1), identifier(range + 1), start(range + 1), end(range + 1), depth(range + 1), root(range + 1), length(range + 1);
    std::vector<std::vector<int>> edges(range + 1);
    
    for(int i=0;i<len;i++){
        array_a[i]=arr[i];
    }
    for (int i = 1; i <= range; i++){
        array_b[i]=brr[i-1];
    }

    for (int i = 1; i <= range; i++) {
        if (!visited[i]) {
            int node_x = i;
            while (!visited[node_x]) {
                visited[node_x] = i;
                node_x = array_b[node_x];
            }
            if (visited[node_x] == i) {
                int node_u = node_x, counter = 0;
                do {
                    identifier[node_u] = ++counter;
                    node_u = array_b[node_u];
                } while (node_x != node_u);
                length[i] = counter;
            }
            for (int node_u = i; node_u != node_x; node_u = array_b[node_u]) {
                edges[array_b[node_u]].push_back(node_u);
            }
        }
    }

    std::function<void(int)> dfs = [&](int node_x) {
        start[node_x] = ++total;
        for (int node_y : edges[node_x]) {
            root[node_y] = root[node_x];
            depth[node_y] = depth[node_x] + 1;
            visited[node_y] = visited[node_x];
            dfs(node_y);
        }
        end[node_x] = total;
    };
    
    for (int i = 1; i <= range; i++) {
        if (identifier[i]) {
            root[i] = i;
            dfs(i);
        }
    }

    std::function<int(int, int)> distance = [&](int node_x, int node_y) {
        if (start[node_y] <= start[node_x] && end[node_x] <= end[node_y]){
            return depth[node_x] - depth[node_y];
        }
        if (visited[node_x] == visited[node_y] && identifier[node_y]) {
            int size = length[visited[node_x]];
            return depth[node_x] + (identifier[node_y] - identifier[root[node_x]] + size) % size;
        }
        return range;
    };

    std::function<bool(int)> check = [&](int node_x) {
        int pos = 1;
        for (int value : array_a) {
            while (pos <= range && distance(value, pos) > node_x){
                pos++;
            }
            if (pos > range){
                return false;
            }
        }
        return true;
    };

    int left = 0, right = range - 1, answer = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (check(mid)) {
            right = (answer = mid) - 1;
        } else {
            left = mid + 1;
        }
    }
    return answer;
}

#include <functional>
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <cassert>
#include <stdexcept>


int main() {
    std::cin.tie(0)->sync_with_stdio(0);
    int testCases;
    std::cin >> testCases;
    while (testCases--) {
        int len,range;
        std::cin >> len >> range;
        std::vector<int> arr,brr;
        for(int i=0;i<len;i++){
            int node_x;
            std::cin>>node_x;
            arr.push_back(node_x);
        }
        for(int i=0;i<range;i++){
            int node_x;
            std::cin>>node_x;
            brr.push_back(node_x);
        }
        int ans=LongWayToBeNondecreasing(len,range,arr,brr);
        std::cout<<ans<<std::endl;
    }
    return 0;
}
